<html>
<!-- $Updated: 2012/03/27 -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>Lomse library. Tutorial 4 for wxWidgets</title>
<link rel="stylesheet" media="all" href="singledoc.css" type="text/css" />
</head>
<body>

<h1>Lomse library. Tutorial 4 for wxWidgets</h1>
<!--====================================================-->

<p>
In previous tutorial we learn that visual highlight effects during score playback (visual tracking by highlighting notes being played and/or by displaying a vertical tempo line marking beats) is automatically done by Lomse. Your application will just receive <i>update view</i> events when the display should be updated, and all you have to do is to copy the already updated rendering bitmap onto the window.
</p>

<p>
But when delegating in Lomse all score highlight management, there are two threads working concurrently: your application thread, running the application code, and Lomse playback thread, running all playback code. As both are using the same resources (the internal model, the graphical model and the render bitmap), during playback your application can not do any action that could result in modifying the internal model, the graphical model or the render bitmap, unless you include safeguarding code to avoid conflicts when both threads try to modify simultaneously these shared resources.
</p>

<p>
A different approach for visual highlight effects during score playback is also possible: instead of delegating its management to Lomse and receiving only <i>update view</i> events, your application can opt for directly handling the <i>score highlight</i> events. With this approach, visual highlight code will run in the same thread than your application code, thus avoiding the commented concurrency problems without having to add safeguarding code.
</p>

<p>
In this tutorial we are going to learn how to do this. You can download the full source code for this example from
<a href="../../examples/example_4_wxwidgets.cpp">../../examples/example_4_wxwidgets.cpp</a>.
</p>



<h2><a name="">Table of content</a></h2>
<!--====================================================-->

<ol>
<li><a href="#highlight">Lomse playback: score highlight events</li></a>
<li><a href="#receiving">Changes for receiving score highlight events</li></a>
<li><a href="#handling">Defining our application events</li></a>
<li><a href="#mycanvas">Changes for handling our application events</a></li>
<li><a href="#compile">Compiling your code and building</a></li>
<li><a href="#conclusions">Conclusions</a></li>
</ol>





<h2><a name="highlight">1. Lomse playback: score highlight events</h2></a>
<!--====================================================-->

<p>
As we learn in previous tutorial, invocation of <tt>ScorePlayer::play()</tt> method will trigger all the playback machinery. As a consequence, Lomse will start playback and will generate two types of events: <i>sound</i> events and <i>score highlight</i> events. Sound event must always be handled by your application code, but handling <i>score highlight</i> events is optional.
</p>

<p>
By default, Lomse will assume that your application will <b>do</b> handle all <i>score highlight</i> events. Therefore, if you would like that Lomse handle these events instead of posting them to your application, it is necessary to request it by invoking <tt>ScorePlayer</tt> method <tt>post_highlight_events</tt>. That's what we did in tutorial 3. If you review the code from that tutorial you will see that at <tt>ScorePlayer</tt> creation we did:
</p>

<pre class="code">
MidiServer* pMidi = ...
ScorePlayer* pPlayer = m_lomse.create_score_player(pMidi);
pPlayer->post_highlight_events(false);
</pre>

<p>
That is, we instructed <tt>ScorePlayer</tt> to not send highlight events. In this tutorial we will change last sentence to:
</p>

<pre class="code">
pPlayer->post_highlight_events(true);
</pre>

<p>
This change will modify <tt>ScorePlayer</tt> behaviour and, as consequence, our application will receive all <i>score highlight</i> events, instead of being handled internally by Lomse.
</p>

<div class="warning">
<p>
When your application handles <i>score highlight</i> events it is important to return control to Lomse as soon as possible. This is because, currently, Lomse does not implement an event subsystem with its own thread. Instead Lomse sends events to your application by invoking a callback. This implies that your application code for handling the event is processed by the Lomse thread. As this thread is dealing with sound generation, any delay will cause delays in sound generation, which will be unacceptable. Therefore, to avoid delays, the suggested way for handling <i>score highlight</i> events is to generate an application event and to enqueue it in the application events system.
</p>
</div>

<p>
In your application, processing an <i>score highlight</i> event can be as complex as you like, and to generate any fancy visual feedback. Alternatively, it can be a trivial task, as Lomse provides standard event handlers for creating standard visual effects (coloured notes, tempo line or both). If you would like to use Lomse standard visual effects, your application code should be just passing the event to the interactor, and it will take care of all necessary tasks. Finally, your application will receive an <i>update view</i> event, and all you have to do is to copy the already updated rendering bitmap onto the window.
</p>

<p>
As you can see, handling <i>score highlight</i> events in your application is a round trip to, finally, delegate its handling on Lomse! But this round trip has an important gain: the code for implementing visual highlight is executed in your application thread instead of in Lomse playback thread. As a consequence, all concurrency problems automatically disappear!
</p>

<p>
To avoid this burden in your application, probably the best solution will be to implement, in Lomse, an event subsystem with its own thread. But there is a lot of work to do and I have to prioritize the necessities. If you would like to contribute to Lomse project by working on this issue you are welcome. Please post me a message. Thank you.
</p>




<h2><a name="receiving">2. Changes for receiving score highlight events</h2></a>
<!--====================================================-->

<p>
In this tutorial we will use the code from tutorial 3 and modify it for handling <i>score highlight</i> events.
</p>

<p>
The first change is to inform Lomse that our application will handle the <i>score highlight</i> events. For this, it is enough to change the code in <tt>MyFrame::get_score_player()</tt>. This is the original code:

<pre class="code">
ScorePlayer* MyFrame::get_score_player()
{
    if (!m_pPlayer)
    {
        MidiServer* pMidi = get_midi_server();
        m_pPlayer = m_lomse.create_score_player(pMidi);
        m_pPlayer->post_highlight_events(false);
    }
    return m_pPlayer;
}
</pre>

<p>
The change to do is to remove sentence:
</p>

<pre class="code">
m_pPlayer->post_highlight_events(false);
</pre>

<p>
Alternatively, change the parameter to <tt>true</tt>. With any of these changes we instruct <tt>ScorePlayer</tt> to post <i>score highlight</i> events to our application.
</p>



<h2><a name="handling">3. Defining our application events</h2></a>
<!--====================================================-->

<p>
Next step is to prepare our application to handle these events. For this, we will define a callback method in <tt>MyFrame</tt>. This is the standard procedure for handling events, of any type, sent by Lomse. As explained in tutorial 2 (see section <a href="tutorial-2-wx.htm#paint" target="_blank">Events sent by Lomse</a>) setting a callback requires defining two methods: an static one (the wrapper method) and the real one that will do the job. Here is our definition:
</p>

<pre class="code">
class MyFrame: public wxFrame
{
public:
    ...
    //callback wrappers
    ...
    static void wrapper_lomse_event(void* pThis, SpEventInfo pEvent);

protected:
    ...
    void on_lomse_event(SpEventInfo pEvent);
</pre>

<p>
Apart of defining the callback method we have to inform Lomse about its existence!. We do it at Lomse initialization:
</p>

<pre class="code">
void MyFrame::initialize_lomse()
{
    ...
    //set required callbacks
    ...
    m_lomse.set_notify_callback(this, wrapper_lomse_event);
}
</pre>

<p>
Implementing these methods is straightforward. The wrapper method is just invoking the real one:
</p>

<pre class="code">
void MyFrame::wrapper_lomse_event(void* pThis, SpEventInfo pEvent)
{
    static_cast<MyFrame*>(pThis)->on_lomse_event(pEvent);
}
</pre>

<p>
As to the method doing the real work, it has to create an application event and to enqueue it in the application events system. Therefore, before coding this method we have to define our own application event. We have to deal with Lomse events of type <tt>k_highlight_event</tt>. Therefore we will define an equivalent wxWidgets event: <tt>MyScoreHighlightEvent</tt>. It will wrap the Lomse event. As this is standard wxWidgets coding, I will not enter into details. Here is the declaration:
</p>

<pre class="code">
//---------------------------------------------------------------------------------------
// MyScoreHighlightEvent
//      An event to signal different actions related to
//      highlighting / unhighlighting notes while they are being played.
//---------------------------------------------------------------------------------------

DECLARE_EVENT_TYPE( MY_EVT_SCORE_HIGHLIGHT_TYPE, -1 )

class MyScoreHighlightEvent : public wxEvent
{
private:
    SpEventScoreHighlight m_pEvent;   //lomse event

public:
    MyScoreHighlightEvent(SpEventScoreHighlight pEvent, int id = 0)
        : wxEvent(id, MY_EVT_SCORE_HIGHLIGHT_TYPE)
        , m_pEvent(pEvent)
    {
    }

    // copy constructor
    MyScoreHighlightEvent(const MyScoreHighlightEvent& event)
        : wxEvent(event)
        , m_pEvent( event.m_pEvent )
    {
    }

    // clone constructor. Required for sending with wxPostEvent()
    virtual wxEvent *Clone() const { return new MyScoreHighlightEvent(*this); }

    // accessors
    SpEventScoreHighlight get_lomse_event() { return m_pEvent; }
};

typedef void (wxEvtHandler::*ScoreHighlightEventFunction)(MyScoreHighlightEvent&);

#define MY_EVT_SCORE_HIGHLIGHT(fn) \
    DECLARE_EVENT_TABLE_ENTRY( MY_EVT_SCORE_HIGHLIGHT_TYPE, wxID_ANY, -1, \
    (wxObjectEventFunction) (wxEventFunction) (wxCommandEventFunction) (wxNotifyEventFunction) \
    wxStaticCastEvent( ScoreHighlightEventFunction, & fn ), (wxObject *) NULL ),
</pre>

<p>
And the definition:
</p>

<pre class="code">
DEFINE_EVENT_TYPE( MY_EVT_SCORE_HIGHLIGHT_TYPE )
</pre>


<p>
Having defined our event, now we can code the required <tt>MyFrame::on_lomse_event</tt> method. Here is the code:
</p>


<pre class="code">
void MyFrame::on_lomse_event(SpEventInfo pEvent)
{
    MyCanvas* pCanvas = get_active_canvas();

    switch (pEvent->get_event_type())
    {
        case k_highlight_event:
        {
            if (pCanvas)
            {
                SpEventScoreHighlight pEv(
                    boost::static_pointer_cast<EventScoreHighlight>(pEvent) );
                MyScoreHighlightEvent event(pEv);
                ::wxPostEvent(pCanvas, event);
            }
            break;
        }

        default:
            ;
    }
}
</pre>

<p>
As you can see, what we do is to transform the Lomse event into a wxWidgets event, and to inject the wxEvent into the application event handling loop. That's all. Control returns immediately to Lomse, so that Lomse playback thread is not delayed. And our wxWidgets event will be processed when Lomse is idle. But for processing these wxWidgets events we have to define event handler.
</p>



<h2><a name="mycanvas">4. Changes for handling score highlight events</h2></a>
<!--====================================================-->

<p>
Our playback events will be processed in <tt>MyCanvas</tt>. For this, first thing to do is to modify our events table, adding a new handler:
</p>

<pre class="code">
BEGIN_EVENT_TABLE(MyCanvas, wxWindow)
    ...
    MY_EVT_SCORE_HIGHLIGHT(MyCanvas::on_visual_highlight)
END_EVENT_TABLE()
</pre>

<p>
Next, we will define the handler method:
</p>

<pre class="code">
class MyCanvas : public wxWindow
{
    ...
protected:
    //event handlers
    ...
    void on_visual_highlight(MyScoreHighlightEvent& event);
</pre>

<p>
As we will implement standard visual effects, the implementation of this method is trivial, as it is just delegating in Lomse:
</p>

<pre class="code">
void MyCanvas::on_visual_highlight(MyScoreHighlightEvent& event)
{
    SpEventScoreHighlight pEv = event.get_lomse_event();
    m_pInteractor->on_visual_highlight(pEv);
}
</pre>

<p>
And this is all. Our code is now finished and our application is ready for building and testing. You can download the full source code for this example from
<a href="../../examples/example_4_wxwidgets.cpp">../../examples/example_4_wxwidgets.cpp</a>.
</p>



<h2><a name="compile">5. Compiling your code and building</a></h2>
<!--====================================================-->

<p>
At this point, we could compile and tests all these changes. Please follow the instructions in Tutorial 3.
</p>

<p>
When executing example-4 and playing the score you will hear the music and you will see that notes get coloured in red as they are being played. You should see something as:
</p>

<a class="image-reference" href="./images/example-3-wx.png">
<img class="center" src="./images/example-3-wx.png" width="500px" />
</a>

<p>
Play with the program. Resize the window while it is playing back an score and you will see that it works perfectly: sound goes in time and it doesn't crash: all problems of sample code in tutorial 3 are solved!



<h2><a name="conclusions">6. Conclusions</a></h2>
<!--====================================================-->

<p>
In this tutorial I have shown the right way to implement visual effects during score playback, to avoid the concurrency problems present in tutorial 3. Handling score highlight events in your application also opens the door for creating your own visual effects as you are not limited by standard visual effects canned in Lomse.
</p>

<p>
If you would like to contribute with more tutorials or by adapting this tutorial for other platforms, you are welcome!. Join the Lomse list and post me a message.
</p>


</body>
</html>
