<html>
<!-- $Updated: 2012/03/29 -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>Lomse library. Tutorial 3 for wxWidgets</title>
<link rel="stylesheet" media="all" href="singledoc.css" type="text/css" />
</head>
<body>

<h1>Lomse library. Tutorial 3 for wxWidgets</h1>
<!--====================================================-->

<p>
In this third tutorial we are going to see how to add score playback capabilities to your application. You can download the full source code for this example from <a href="../../examples/example_3_wxwidgets.cpp">../../examples/example_3_wxwidgets.cpp</a>.
</p>



<h2><a name="">Table of content</a></h2>
<!--====================================================-->

<ol>
<li><a href="#playback-intro">How Lomse playback works</li></a>
<li><a href="#specifications">Specifications</li></a>
<li><a href="#wxmidi">Changes for using wxMidi</li></a>
<li><a href="#midi-server">Definition and implementation of class MidiServer</li></a>
<li><a href="#midi-dlg">Initial dialog for Midi settings</a></li>
<li><a href="#testing-sound">Testing sound</a></li>
<li><a href="#menu">Additional menu items</a></li>
<li><a href="#score-player">Creating ScorePlayer object</a></li>
<li><a href="#mycanvas">Modifications in MyCanvas for score playback</a></li>
<li><a href="#compile">Compiling your code and building</a></li>
<li><a href="#sound-problems">Problems with MIDI sound in Linux</li></a>
<li><a href="#conclusions">Conclusions</a></li>
</ol>





<h2><a name="playback-intro">1. How Lomse playback works</h2></a>
<!--====================================================-->

<p>
Lomse provides class <tt>ScorePlayer</tt>, that takes care of most of the work to do. By using it, playing an score is just two tasks:
</p>
<ol>
    <li>Load the score to play in the <tt>ScorePlayer</tt> instance.</li>
    <li>Ask <tt>ScorePlayer</tt> to play it, specifying the desired options (i.e. visual tracking, metronome settings, count-off, etc).</li>
</ol>
<p>
This is an excerpt of the needed code:
</p>

<pre class="code">
    //step 1: prepare for playing back the score
    ImoScore* pScore = ...
    ScorePlayer* pPlayer = ...
    PlayerGui* pPlayerGui = ...
    pPlayer->load_score(pScore, pPlayerGui);

    //step2: set play options and go on
    bool fVisualTracking = true;
    bool fCountOff = false;
    int playMode = k_play_normal_instrument;
    long nMM = 60;    //metronome = 60 beats per minute
    pPlayer->play(fVisualTracking, fCountOff, playMode, nMM, m_pInteractor);
</pre>


<p>
Invocation of <tt>play</tt> method will trigger all the playback machinery. But <b>Lomse will not generate any sounds</b>. Sound generation is always responsibility of your application. What Lomse will do is to generate <i>sound events</i>. Therefore, for playback, your application has two main responsibilities:
</p>

<ol>
    <li>handle sound events</li>
    <li>generate sound for each event</li>
</ol>

<p>
Both tasks are accomplished by creating, in your application, a class derived from <tt>MidiServerBase</tt>. This base class defines the interface for processing MIDI events. Your application has to define a derived class and implement the virtual methods. Your class will receive the sound events and will have the responsibility of generating the sounds. Lomse does not impose any restriction about sound generation other than low latency. Perhaps, the simpler method to generate sounds is to rely on the MIDI synthesizer of the PC sound card.  But any other alternatives are possible. By the way, I would like to modify Lomse library to add an interface to the JACK audio system (<a href="http://jackaudio.org/" target="_blank">
http://jackaudio.org/</a>). If you are interested in taking this task you are welcome. Please post me a message. Thank you!
</p>

<p>
<tt>ScorePlayer</tt> constructor requires an instance of the <tt>MidiServer</tt> to use:
</p>

<pre class="code">
    MidiServer* pMidi = new MidiServer();
    ScorePlayer* pPlayer = m_lomse->create_score_player(pMidi);
</pre>

<p>
With this, all playback machinery is in place.
</p>

<p>
As to visual tracking effects (highlighting notes being played and/or displaying a vertical tempo line marking beats),  Lomse will also post <i>score highlight</i> events, to be handled by your application. By handling them you will have full control, and your application can create whatever fancy visual tracking effects you would like.
</p>

<p>Nevertheless, Lomse implements standard visual effects so you can delegate in Lomse for generating visual effects. In this case, your application will just receive <i>update view</i> events when the display should be updated, and all you have to do is to copy the already updated rendering bitmap onto the window. All the required code for updating the display is already included in code from tutorial 2.
</p>

<p>
Finally, for controlling playback some GUI controls (buttons, menu items, etc. to trigger start, stop, pause actions) are required. Lomse gives your application two options for this:
</p>

<ol>
    <li>The first one is to create your own play/pause/stop control mechanism. For instance, you could use menu items, buttons in the toolbar, etc.</li>
    <li>The other alternative is to display, embedded the document, near the score, a <i>player control</i> widget (the typical play/stop buttons, plus playback information that we see in many media players). Lomse has such control (class </tt>ScorePlayerCtrl</tt>) but this is an advanced topic that requires knowledge of Lomse controls and dynamic content creation. So, I will explain nothing about it in this tutorial.</li>
</ol>

<p>
So, as you can see, implementing score playback is simple, and the only burden for your application is coding a <tt>MidiServer</tt> class for generating the sounds.
</p>


<h2><a name="specifications">2. Specifications</h2></a>
<!--====================================================-->

<p>
In this third tutorial we are going to see how to add score playback capabilities to your application.
For controlling playback we are going to add some menu items (play, pause, stop) to the application main menu.
</p>

<p>
For sound generation we will use the wxMidi (<a href="http://www.lenmus.org/en/wxmidi/intro">http://www.lenmus.org/en/wxmidi/intro</a>) component. It is just a wrapper for using the PortMidi library (<a href="http://sourceforge.net/apps/trac/portmedia/wiki/portmidi" target="_blank">http://sourceforge.net/apps/trac/portmedia/wiki/portmidi</a>) in wxWidgets applications.
</p>

<p>
In this tuturial on score playback we will have to devote a lot of time to something not directly related to using Lomse: sound generation. Therefore, I will split this toturial into two. In this tutorial we are not going to generate any visual tracking effects during playback. And we will do it in fourth tutorial.
</p>

<p>
At program start we need to present user a dialog for choosing the midi synthesizer to use.
We also have to add menu items for displaying again this settings dialog whenever the user likes to change Midi settings.
</p>

<p>
We are going to use the <a href="../../examples/example_2_wxwidgets.cpp">code from example 2</a> and add more functionality to it. The changes to do are the following:
</p>

<ol>
    <li>Definitions for using wxMidi</li>
    <li>Definition and implementation of class MidiServer, for generating sounds</tt>.</li>
    <li>Initial dialog for Midi settings.</li>
    <li>Menu items for displaying dialog and for score playback: play, pause, stop.</li>
    <li>Modifications in <tt>MyFrame</tt> for displaying dialog at start up.</li>

    <li>Modifications in <tt>MyFrame</tt> for creating <tt>MidiServer</tt> and <tt>ScorePlayer</tt>.</li>
    <li>Modifications in <tt>MyFrame</tt> for dealing with 'Play', 'Pause' and 'Stop' menu items.</li>
    <li>Modifications in <tt>MyCanvas</tt> for score playback.</li>
</ol>

<p>
Let's start programming.
</p>



<h2><a name="wxmidi">3. Changes for using wxMidi</h2></a>
<!--====================================================-->

<p>
First, download package wxMidi. It is not necessary to install anything, just download the sources. The recommended approach for using wxMidi is to include wxMidi sources in your application source tree. wxMidi is just two .cpp files and one header file. Place them in the same folder than example_3_wx.cpp file. For instance, you could have the following source tree:
</p>

<pre>
tutorial-3
    |
    +-- example-3-wxwidgets.cpp
    +-- wxMidi
           |
           +-- wxMidi.cpp
           +-- wxMidiDatabase.cpp
           +-- wxMidi.h
</pre>


<p>
Before compiling our example, take into account that it is necessary to install and link with PortMidi library. Perhaps this is the right time to ensure that you have PortMidi installed in your system. See wxMidi install instructions, included in the wxMidi package.
</p>

<p>Now, let's start modifying code from tutorial 2 by adding <tt>wxMidi</tt> headers:
</p>

<pre class="code">
//wxMidi headers
#include &lt;wxMidi.h&gt;
</pre>



<h2><a name="midi-server">4. Definition and implementation of class MidiServer</h2></a>
<!--====================================================-->

<p>For using wxMidi we will define class <tt>MidiServer</tt>, derived from <tt>MidiServerBase</tt>- It will implement virtual methods, defined in base class, for creating sounds. Implementation of <tt>MidiServer</tt> is very simple as it is just using the services provided by <tt>wxMidi</tt> class. The definition of <tt>MidiServerBase</tt> class is in header lomse_score_player.h (add now this header to the example code). The class is as follows:
</p>

<pre class="code">
class MidiServerBase
{
public:
    MidiServerBase() {}
    virtual ~MidiServerBase() {}

    virtual void program_change(int channel, int instr) {}
    virtual void voice_change(int channel, int instr) {}
    virtual void note_on(int channel, int pitch, int volume) {}
    virtual void note_off(int channel, int pitch, int volume) {}
    virtual void all_sounds_off() {}
};
</pre>

<p>
Our derived class is quite simple. We will just define two pointers to keep references to the relevant <tt>wxMidi</tt> objects: <tt>wxMidiSystem</tt>, that represents the whole Midi synthesizer, and <tt>wxMidiOutDevice</tt>, that represents the output device, that is, the device that will create the sounds. I also have defined a couple of variables to contain current Midi configuration, and have added three helper methods. Here is the definition:
</p>

<pre class="code">
class MidiServer : public MidiServerBase
{
protected:
    wxMidiSystem*  m_pMidiSystem;       //MIDI system
    wxMidiOutDevice*  m_pMidiOut;       //out device object

    //MIDI configuration information
    int     m_nOutDevId;
    int     m_nVoiceChannel;

public:
    MidiServer();
    ~MidiServer();

    //get number of available Midi devices
    int count_devices();

    //set up configuration
    void set_out_device(int nOutDevId);

    //create some sounds to test Midi
    void test_midi_out();

    //mandatory overrides from MidiServerBase
    void program_change(int channel, int instr);
    void voice_change(int channel, int instr);
    void note_on(int channel, int pitch, int volume);
    void note_off(int channel, int pitch, int volume);
    void all_sounds_off();
};
</pre>

<p>
Implementation is very simple. The constructor is just initializing variables and getting the address of the <tt>wxMidiSystem</tt> object. This object represents the whole Midi interface. This is the code:
</p>

<pre class="code">
MidiServer::MidiServer()
    : m_pMidiSystem( wxMidiSystem::GetInstance() )
    , m_pMidiOut(NULL)
    , m_nOutDevId(-1)
    , m_nVoiceChannel(0)    // 0 based. So this is channel 1
{
}
</pre>

<p>
The destructor is just closing the out device and deleting the <tt>wxMidi</tt> related objects:
</p>

<pre class="code">
MidiServer::~MidiServer()
{
    if (m_pMidiOut)
        m_pMidiOut->Close();

    delete m_pMidiOut;
    delete m_pMidiSystem;
}
</pre>

<p>
Apart of the mandatory virtual methods, I have added three new methods. First one, <tt>count_devices</tt> is getting the number of Midi devices installed in your PC. We need it for the Midi settings dialog. This is the code:
</p>

<pre class="code">
int MidiServer::count_devices()
{
    return m_pMidiSystem->CountDevices();
}
</pre>

<p>
Next one, <tt>set_out_device</tt>, is for choosing the device that will be used for generating sounds. We will use it also in the Midi settings dialog. The basic code is just creating a <tt>wxMidiOutDevice</tt> instance:
</p>

<pre class="code">
    m_pMidiOut = new wxMidiOutDevice(m_nOutDevId);
</pre>

<p>
But the real code is just slightly more complex due to error checking and to allowing the user for changing Midi settings multiple times. This is the code:
</p>

<pre class="code">
void MidiServer::set_out_device(int nOutDevId)
{
    wxMidiError nErr;

    //if out device Id has changed close current device and open the new one
    if (!m_pMidiOut || (m_nOutDevId != nOutDevId))
    {
        //close current device
         if (m_pMidiOut)
         {
            nErr = m_pMidiOut->Close();
            delete m_pMidiOut;
            m_pMidiOut = NULL;
            if (nErr)
            {
                wxMessageBox( wxString::Format(
                    _T("Error %d while closing Midi device: %s \n")
                    , nErr, m_pMidiSystem->GetErrorText(nErr).c_str() ));
                return;
            }
        }

        //open new one
        m_nOutDevId = nOutDevId;
        if (m_nOutDevId != -1)
        {
            try
            {
                m_pMidiOut = new wxMidiOutDevice(m_nOutDevId);
                nErr = m_pMidiOut->Open(0, NULL);        // 0 latency, no driver user info
            }
            catch(...)      //handle all exceptions
            {
                wxLogMessage(_T("[MidiServer::set_out_device] Crash opening Midi device"));
                return;
            }

            if (nErr)
                wxMessageBox( wxString::Format(
                    _T("Error %d opening Midi device: %s \n")
                    , nErr, m_pMidiSystem->GetErrorText(nErr).c_str() ));
            else
                wxMessageBox(_T("Midi out device correctly set."));
        }
    }
}
</pre>

<p>
Finally, I have added a test method for generating some sounds, to be used for checking that Midi settings are valid and the Midi interface works. This is useful for checking the Midi system if score playback doesn't produce sounds!. Here is the code:
</p>

<pre class="code">
void MidiServer::test_midi_out()
{
    if (!m_pMidiOut) return;

    //Play a scale
    int scale[] = { 60, 62, 64, 65, 67, 69, 71, 72 };
    #define SCALE_SIZE 8

    for (int i = 0; i < SCALE_SIZE; i++)
    {
        m_pMidiOut->NoteOn(m_nVoiceChannel, scale[i], 100);
        ::wxMilliSleep(200);    // wait 200ms
        m_pMidiOut->NoteOff(m_nVoiceChannel, scale[i], 100);
    }
}
</pre>

<p>
And now we will implement the required virtual methods. This is the simplest part. Here is the code:
</p>

<pre class="code">
void MidiServer::program_change(int channel, int instr)
{
    m_pMidiOut->ProgramChange(channel, instr);
}

void MidiServer::voice_change(int channel, int instrument)
{
    m_nVoiceChannel = channel;
    if (m_pMidiOut)
    {
        wxMidiError nErr = m_pMidiOut->ProgramChange(channel, instrument);
        if (nErr)
        {
            wxMessageBox( wxString::Format(
                _T("Error %d in ProgramChange:\n%s")
                , nErr, m_pMidiSystem->GetErrorText(nErr).c_str() ));
        }
    }
}

void MidiServer::note_on(int channel, int pitch, int volume)
{
    m_pMidiOut->NoteOn(channel, pitch, volume);
}

void MidiServer::note_off(int channel, int pitch, int volume)
{
    m_pMidiOut->NoteOff(channel, pitch, volume);
}

void MidiServer::all_sounds_off()
{
    m_pMidiOut->AllSoundsOff();
}
</pre>

<p>With this we have finished our sound generator based on <tt>wxMidi</tt>. Now we have to modify <tt>MyFrame</tt> class for using it. We will modify <tt>MyFrame</tt> definition by adding a pointer to <tt>MidiServer</tt> instance and an accessor method for creating the instance, if not created, and returning it. First, changes in <tt>MyFrame</tt> definition:
</p>

<pre class="code">
class MyFrame: public wxFrame
{
    ...
protected:
    ...
    //sound related
    MidiServer* get_midi_server();

    MidiServer* m_pMidi;
    ...
</pre>

<p>
And now the implementation. First, we modify <tt>MyFrame</tt> constructor to initialize <tt>m_pMidi</tt> to <tt>NULL</tt>. and we modify destructor to delete it. Finally, we define the accessor method:
</p>

<pre class="code">
MidiServer* MyFrame::get_midi_server()
{
    if (!m_pMidi)
        m_pMidi = new MidiServer();
    return m_pMidi;
}
</pre>

<p>
With this, we have all necessary changes for using Midi. The only missing issue is the initial dialog to set Midi device. We will deal with it in next section.
</p>



<h2><a name="midi-dlg">5. Initial dialog for Midi settings</h2></a>
<!--====================================================-->

<p>
To reduce the size of the example code, instead of coding our own dialog, we will use function <tt>::wxGetSingleChoiceIndex</tt>. It pops up a dialog box containing a message, 'OK' and 'Cancel' buttons and a single-selection listbox. In this listbox the user will select the Midi output device. All other Midi settings will be defaulted to wxMidi default values. In a real application you will have to code a better dialog, including more Midi parameters and other options.
</p>

<pre class="code">
void MyFrame::show_midi_settings_dlg()
{
    wxArrayString outDevices;
    vector<int> deviceIndex;

    //get available Midi out devices
    MidiServer* pMidi = get_midi_server();
    int nNumDevices = pMidi->CountDevices();
    for (int i = 0; i < nNumDevices; i++)
    {
        wxMidiOutDevice device(i);
        if (device.IsOutputPort())
        {
            outDevices.Add( device.DeviceName() );
            deviceIndex.push_back(i);
        }
    }

    int iSel = ::wxGetSingleChoiceIndex(
                    _T("Select Midi output device to use:"),    //message
                    _T("Midi settings dlg"),                    //window title
                    outDevices,
                    this                                        //parent window
                 );
    if (iSel == -1)
    {
        //the user pressed cancel
        //
    }
    else
    {
        //set current selection
        MidiServer* pMidi = get_midi_server();
        int deviceID = deviceIndex[iSel];   //output device
        pMidi->SetOutDevice(deviceID);
    }
}
</pre>

<p>
Now, I will modify <tt>MyFrame</tt> constructor to invoke this method:
</p>

<pre class="code">
MyFrame::MyFrame()
    : wxFrame(NULL, wxID_ANY, _T("Lomse sample for wxWidgets"),
              wxDefaultPosition, wxSize(850, 600))
    , m_pMidi(NULL)
{
    create_menu();
    initialize_lomse();
    show_midi_settings_dlg();
    ...
</pre>

<p>
Next, we will add menu items for displaying the Midi settings dialog and for testing the Midi interface. All these new items will be arranged under a 'Sound' submenu.
This is usual wxWidgets stuff. We have to define IDs for these new menu items (<code>k_menu_midi_test</code> and <code>k_menu_midi_settings</code>). After this, we modify our our <code>create_menu()</code> method as follows:
</p>

<pre class="code">
    ...
    wxMenu *soundMenu = new wxMenu;
    soundMenu->Append(k_menu_midi_settings, _T("&Midi settings"));
    soundMenu->Append(k_menu_midi_test, _T("Midi &test"));
    ...
    menuBar->Append(soundMenu, _T("&Sound"));
</pre>

<p>Now, we have to modify MyFrame class to add handlers for the new menu events. Remember that we also have to modify the events table:
</p>

<pre class="code">
    EVT_MENU(k_menu_midi_settings, MyFrame::on_midi_settings)
    EVT_MENU(k_menu_midi_test, MyFrame::on_sound_test)
</pre>

<p>
Finally, we code these two methods:
</p>

<pre class="code">
void MyFrame::on_midi_settings(wxCommandEvent& WXUNUSED(event))
{
    show_midi_settings_dlg();
}

void MyFrame::on_sound_test(wxCommandEvent& WXUNUSED(event))
{
    MidiServer* pMidi = get_midi_server();
    if (!pMidi) return;
    pMidi->test_midi_out();
}
</pre>




<h2><a name="testing-sound">6. Testing sound</h2></a>
<!--====================================================-->

<p>
Now, compile and build the example code (see section <a href="#compile">Compiling your code and building</a>). It is not yet finished but we can test our Midi interface. When running the program the first thing you will see is the Midi settings dialog, a window similar to one of these:
</p>

<img src="./images/midi-settings-linux.png" />
<img src="./images/midi-settings-win32.png" />

<p>
In these images, you can see the Midi devices created by Timidity software in my Linux system and the Midi devices in my Windows XP system. In Windows, choose any of the devices. In Linux choose one of the Timidity ports 0 to 4, but not the midi through port!
</p>

<p>
After choosing the desired device and clicking on button 'Ok' you will get the main frame, displaying an score. In main menu, you will get a new item 'Sound'. Click on it and select item 'Test Midi'. If everything is ok you should hear an scale. If not, check the sound settings of your computer. The most frequent cause for not hearing any sound is that the Midi synthesizer output is disabled! If you are running the tutorial on Linux see <a href="tutorial-3-wx.htm#sound-problems">"Problems with MIDI sound in Linux"</a>.
</p>

<p>
Once the Midi test is passed, we are ready to continue with more changes in our program.
</p>



<h2><a name="menu">7. Additional menu items</h2></a>
<!--====================================================-->

<p>
Now we will add menu items for score playback: 'Play', 'Pause' and 'Stop'. All these new items will be arranged under the 'Sound' submenu.
This is usual wxWidgets stuff. We have to define IDs for these new menu items (<code>k_menu_play_start</code>, <code>k_menu_play_stop</code> and <code>k_menu_play_pause</code>). After this, we modify our our <code>create_menu()</code> method as follows:
</p>

<pre class="code">
    wxMenu *soundMenu = new wxMenu;
    soundMenu->Append(k_menu_play_start, _T("&Play"));
    soundMenu->Append(k_menu_play_stop, _T("&Stop"));
    soundMenu->Append(k_menu_play_pause, _T("Pause/&Resume"));
    soundMenu->Append(k_menu_midi_settings, _T("&Midi settings"));
    soundMenu->Append(k_menu_midi_test, _T("Midi &test"));
    ...
    menuBar->Append(soundMenu, _T("&Sound"));
</pre>

<p>Now, we have to modify MyFrame class to add handlers for the new menu events. Remember that we also have to modify the events table:
</p>

<pre class="code">
    EVT_MENU(k_menu_play_start, MyFrame::on_play_start)
    EVT_MENU(k_menu_play_stop, MyFrame::on_play_stop)
    EVT_MENU(k_menu_play_pause, MyFrame::on_play_pause)
</pre>

<p>
The methods for handling these events are quite simple as we just delegate on <tt>MyCanvas</tt>:
</p>

<pre class="code">
void MyFrame::on_play_start(wxCommandEvent& WXUNUSED(event))
{
    get_active_canvas()->play_start();
}

void MyFrame::on_play_stop(wxCommandEvent& WXUNUSED(event))
{
    get_active_canvas()->play_stop();
}

void MyFrame::on_play_pause(wxCommandEvent& WXUNUSED(event))
{
    get_active_canvas()->play_pause();
}
</pre>



<h2><a name="score-player">8. Creating ScorePlayer object</h2></a>
<!--====================================================-->

<p>
before coding the necessary changes in <tt>MyCanvas</tt> it is necessary to create the <tt>ScorePlayer</tt> object. It should be a global object, accessible from any point at which it is necessary to play an score. In our simple example, I will put this object as member of <tt>MyFrame</tt> and will pass it to <tt>MyCanvas</tt> in the constructor. Therefore, I will change <tt>MyFrame</tt> declaration to define a member variable and a getter method:
</p>

<pre class="code">
class MyFrame: public wxFrame
{
    ...
protected:
    ...
    //sound related
    ...
    ScorePlayer* get_score_player();

    ScorePlayer* m_pPlayer;
    ...
</pre>


<p>
In <tt>MyFrame</tt> constructor the new variable <tt>m_pPlayer</tt> is initialized to <tt>NULL</tt>, and the <tt>ScorePlayer</tt> creation is delayed until really needed:
</p>

<pre class="code">
ScorePlayer* MyFrame::get_score_player()
{
    if (!m_pPlayer)
    {
        MidiServer* pMidi = get_midi_server();
        m_pPlayer = m_lomse.create_score_player(pMidi);
    }
    return m_pPlayer;
}
</pre>

<p>
Finally, we modify <tt>MyCanvas</tt> definition for receiving the <tt>ScorePlayer</tt> object in constructor:
</p>

<pre class="code">
class MyCanvas : public wxWindow
{
public:
    MyCanvas(wxFrame *frame, LomseDoorway& lomse, ScorePlayer* pPlayer);
    ...
protected:
    ...
    // for score playback
    ScorePlayer* m_pPlayer;


MyCanvas::MyCanvas(wxFrame *frame, LomseDoorway& lomse, ScorePlayer* pPlayer)
    : wxWindow(frame, wxID_ANY)
    , m_lomse(lomse)
    , m_pPresenter(NULL)
    , m_pInteractor(NULL)
    , m_buffer(NULL)
    , m_pPlayer(pPlayer)
    , m_view_needs_redraw(true)
{
}
</pre>

<p>
And we modify the code for passing the <tt>ScorePlayer</tt> object when <tt>MyCanvas</tt> instances are created, in <tt>MyFrame</tt> constructor:
</p>


<pre class="code">
MyFrame::MyFrame()
    : wxFrame(NULL, wxID_ANY, _T("Lomse sample for wxWidgets"),
              wxDefaultPosition, wxSize(850, 600))
    , m_pMidi(NULL)
    , m_pPlayer(NULL)
{
    ...
    // create our one and only child -- it will take our entire client area
    m_canvas = new MyCanvas(this, m_lomse, get_score_player());
    ...
</pre>

<p>
With this, we have finished with the modifications required for <tt>MyFrame</tt>.
</p>


<h2><a name="mycanvas">9. Modifications in MyCanvas for score playback</h2></a>
<!--====================================================-->

<p>In <tt>MyFrame</tt> we delegated all playback operations on <tt>MyCanvas</tt>. Therefore, we have now to code these new methods. The first one <tt>play_start</tt> has to load the score in the <tt>ScorePlayer</tt> object (received in constructor) and invoke its <tt>play</tt> method, as was explained in section <a href="tutorial-3-wx.htm#playback-intro">"How lomse playback works"</a>.
</p>

<p>
The main doubt you should have is how to get the score to play. In these tutorials I never explained how access parts of a document, such as a paragraph or a score. In a future tutorial I will explain this in detail but, for now, you should learn that <tt>Document</tt> class has member methods for traversing the document and accessing its components. One of these methods is <tt>get_score(int index)</tt> that takes as argument the index to the desired score. Index 0 is the first score in the document, index 1 the second score, and so on. Therefore, if we assume that the document only contains one score, getting the score to play is just getting the document and invoking <tt>get_score</tt> method:
</p>
<pre class="code">
    Document* pDoc = m_pPresenter->get_document();
    ImoScore* pScore = pDoc->get_score(0);
</pre>

<p>
With this knowledge we can now code the <tt>play_start</tt> method:
</p>

<pre class="code">
void MyCanvas::play_start()
{
    Document* pDoc = m_pPresenter->get_document();
    ImoScore* pScore = pDoc->get_score(0);
    m_pPlayer->load_score(pScore, NULL);

    bool fVisualTracking = true;
    bool fCountOff = false;
    int playMode = k_play_normal_instrument;
    long nMM = 60;
    m_pPlayer->play(fVisualTracking, fCountOff, playMode, nMM, m_pInteractor);
}
</pre>

<p>
The other required methods, <tt>play_stop</tt> and <tt>play_pause</tt>, are trivial:
</p>


<pre class="code">
void MyCanvas::play_stop()
{
    m_pPlayer->stop();
}

void MyCanvas::play_pause()
{
    m_pPlayer->pause();
}
</pre>

<p>
And this is all. Our code is now finished and our application is ready for building and testing. But before doing it I will change code in <tt>open_test_score</tt> to put an score more interesting for playback. You can download the full source code for this example from
<a href="../../examples/example_3_wxwidgets.cpp">../../examples/example_3_wxwidgets.cpp</a>.
</p>



<h2><a name="compile">10. Compiling your code and building</a></h2>
<!--====================================================-->

<p>
At this point, we could compile and tests all these changes. Do not forget to install the PortMidi libraries. For detailed instructions you should see the PortMidi documentation. Nevertheless, on most Linux systems it is just installing the PortMidi package. For instance, execute the following command on a terminal window (enter your password as needed):
</p>

<pre class="command">
sudo apt-get install libportmidi-dev
</pre>

<p>
Headers will be placed at /usr/include/ and libraries at /usr/lib/.
</p>

<p>
Once PortMidi libraries are installed, you can proceed to build your application. For building, you can use the makefile or build command used for tutorials 1 or 2. But you will have to modify it as follows:
</p>

<ul>
    <li>You have to add source files from wxMidi package.
    </li>

    <li>You have to add search directories to look for wxMidi and PortMidi headers.
    For instance, in Linux you will have to add '/usr/include/ and './wxMidi/'.
    </li>

    <li>You will have to link with PortMidi libraries. For instance, in Linux you will have to add
    libportmidi.so and libporttime.so.
    </li>

    <li>And you will have to add the paths for these libraries. For instance, /usr/lib/</li>
</ul>

<p>
With these changes, your build command in Linux will be something as (adjust paths if necessary):
</p>

<pre class="console">
gcc example_3_wxwidgets.cpp ./wxMidi/wxMidi.cpp ./wxMidi/wxMidiDatabase.cpp  \
    -o example-3-wx `wx-config --cflags`                       \
    -I /usr/local/include/lomse  -I /usr/include -I ./wxMidi/  \
    `pkg-config --cflags freetype2` -L /usr/local/lib -llomse  \
    -lportmidi -lporttime `wx-config --libs`
</pre>

<p>
Run the program. You should see something as:
</p>

<a class="image-reference" href="./images/example-3-wx.png">
<img class="center" src="./images/example-3-wx.png" width="500px" />
</a>

<p>
Click on the 'Sound > Midi test' menu item, and check that sounds are produced. When executing example-3 and playing an score you will hear the music but you will not see any visual effects. We will learn in next tutorial how to add visual tracking effects. In Windows systems there should not be any problems with sound but in many Linux distros a MIDI synthesizer is not installed by default. If you have problems with sound, please read next section.
</p>


<h2><a name="sound-problems">11. Problems with MIDI sound in Linux</a></h2>
<!--====================================================-->

<p>
When testing the code in Linux you might find problems with sound as a MIDI synthesizer is not installed by default in some Linux distros. If this is your case have to install a Midi synthesizer. Here you have some references for this:
</p>

<p>
<a href="https://help.ubuntu.com/community/Midi/SoftwareSynthesisHowTo" target="_blank">
https://help.ubuntu.com/community/Midi/SoftwareSynthesisHowTo</a><br />

<a href="https://help.ubuntu.com/community/Midi/HardwareSynthesisSetup" target="_blank">
https://help.ubuntu.com/community/Midi/HardwareSynthesisSetup</a><br />

<a href="http://timidity.sourceforge.net/#info" target="_blank">
http://timidity.sourceforge.net/#info</a><br />
</p>


<h2><a name="conclusions">12. Conclusions</a></h2>
<!--====================================================-->

<p>
In this long tutorial I have introduced score playback. Unfortunately, most of the tutorial is not directly related to using the Lomse library but to generating sounds. In the <a href="tutorial-4-wx.htm">fourth tutorial</a> I will continue with this subject and we will study how to add visual tracking effects during playback.
</p>

<p>
If you would like to contribute with more tutorials or by adapting this tutorial for other platforms, you are welcome!. Join the Lomse list and post me a message.
</p>


</body>
</html>
