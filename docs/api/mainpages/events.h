/**
@page lomse-events Events and Requests


@tableofcontents


@section notifications Notifications: events and requests

As Lomse is platform independent code, it knows nothing about your platform mechanisms for creating events. For this reason, all Lomse communication with the user application takes place through <i>notifications</i>. They are sent to your application by invoking a callback function. Your application, in this function, will process the notifications as more appropiate, probably by creating <tt>real</tt> events for your platform and posting them to be processed when appropriate.

Lomse <i>notifications</i> can be divided into two categories based on how they are created and how they are processed:
	- <b>Events</b>. They are informative notifications: the Lomse library just informs the user application about something, for instance, about a mouse click. Normally, the user application has to do some action but Lomse doesn't expect anything, and continues processing without waiting for any answer. Events can refer:
		- To a View, i.e. a <i>playback higlight</i> event, or a <i>window update</i> event.
		- To a Document or its content, i.e. a <i>mouse click</i> event; and
		- To a Control object, i.e. a click on a link control.

    - <b>Requests</b>. When Lomse needs some information or some platform dependent service it sends a <i>Request</i>. Lomse process is paused until the user application provides the requested data.


@section handlig-events Handling events

It is not mandatory to handle Lomse events. But normally, your application will need to handle at least the <tt>k_update_window_event</tt>.

To capture and handle an event you must register an <tt>event handler</tt> on the object generating the events by invoking its <tt>add_event_handler()</tt> method. Your handler can be:
- a C function,
- a C++ method, or
- a C++ object, derived form lomse::EventHandler.

All Lomse objects that generate events derive from lomse::Observable class. Currently, events can be generated by the following objects:
	- A View. You must register must register an <tt>event handler</tt> on the Interactor for handling the View events.
	- A Document or a document object (ImoContentObj); and
	- A Control object.

The parameters for the <tt>add_event_handler()</tt> method depends on the type of handler method. There are three posibilities:

a) The handler is a C function:
@code
void add_handler(int eventType, void (*pt2Func)(SpEventInfo event) );
@endcode

b) The handler is a C++ method:
@code
void add_handler(int eventType, void* pThis,
	             void (*pt2Func)(void* pObj, SpEventInfo event) );
@endcode

c) The handler is a C++ object derived form lomse::EventHandler:
@code
void add_handler(int eventType, EventHandler* pHandler);
@endcode

The parameters for these methods are:
- <tt>eventType</tt> is the event type you wish to handle, such as a mouse click.

- <tt>SpEventInfo</tt> is an shared pointer to the event object. All events derive from <tt>lomse::EventInfo</tt> class.


For the C function case:
- <tt>pt2Func</tt> is a pointer to the C function that will handle the event. It expects only one parameter: a shared pointer to the Event object.


For C++ method case:
- <tt>pThis</tt> is a pointer to the object that will handle the event.

- <tt>pt2Func</tt> is a pointer to the member method that will handle the event. It must be an <b>static method</b>. It will receive as first parameter the pointer to the object, so that you can invoke non-static methods if necessary. 

And for the C++ object case:
- <tt>pHandler</tt> is a pointer to an object derived from EventHandler that will handle the event. It must implement method <tt>handle_event()</tt>.


Example:

@code
if (SpInteractor spInteractor = m_pPresenter->get_interactor(0).lock())
{
    //connect the View with the window buffer
    spInteractor->set_rendering_buffer(&m_rbuf_window);

    //register to receive some events
    spInteractor->add_event_handler(k_update_window_event, this, wrapper_update_window);
    spInteractor->add_event_handler(k_do_play_score_event, this, wrapper_play_score);
    spInteractor->add_event_handler(k_pause_score_event, this, wrapper_play_score);
    spInteractor->add_event_handler(k_stop_playback_event, this, wrapper_play_score);
	...
@endcode



@subsection view-events View events

Events generated by a View must be handled by adding a handler to the Interactor associated to that View. 

Here is a list of all events generated by the View. For more information on each event read the class documentation for the event.

<b>Global View events:</b>

- EventPaint (event type <tt>k_update_window_event</tt>) - Ask user app to update window with current bitmap.
- EventUpdateViewport (event type <tt>k_update_viewport_event</tt>) - Ask user app to update viewport origin using provided coordinates.

<b>Events related to selecting objects:</b>

- EventUpdateUI (event type <tt>k_selection_set_change</tt>) - Selected objects changed
- EventUpdateUI (event type <tt>k_pointed_object_change</tt>) - Cursor pointing to a different object

<b>Events implying a posible edition command:</b>

- EventControlPointMoved (event type <tt>k_control_point_moved_event</tt>) - User moves a handler: handler released event

<b>Events related to score playback:</b>

- EventScoreHighlight (event type <tt>k_highlight_on_event</tt>) - Add highlight to a note/rest
- EventScoreHighlight (event type <tt>k_highlight_off_event</tt>) - Remove highlight from a note/rest
- EventScoreHighlight (event type <tt>k_end_of_higlight_event</tt>) - End of score play back. Remove all highlight.
- EventScoreHighlight (event type <tt>k_advance_tempo_line_event</tt>) -
- EventPlayScore (event type <tt>k_end_of_playback_event</tt>) - End of playback. User application is
	informed just in case it would like to do any action (i.e. re-enabling playback button).




@subsection document-events Document events

These events are generated by the Document. For handling them you will have to register a handler 
function either to the Document object or to the desired elements (ImoContentObj objects).

<b>Mouse events when interacting with Document objects:</b>

- EventMouse (event type <tt>k_mouse_in_event</tt>) - Mouse goes over an object
- EventMouse (event type <tt>k_mouse_out_event</tt>) - Mouse goes out from an object
- EventMouse (event type <tt>k_on_click_event</tt>) - Document, ImoContentObj: click on object
- EventMouse (event type <tt>k_show_contextual_menu_event</tt>) - Click event: object selected and menu request

<b>Events related to score playback:</b>

- EventPlayScore (event type <tt>k_do_play_score_event</tt>) - Start/resume playback
- EventPlayScore (event type <tt>k_pause_score_event</tt>) - Pause playback
- EventPlayScore (event type <tt>k_stop_playback_event</tt>) - Stop playback



@section handlig-requests Handling requests

It is mandatory to handle Lomse requests. For this, you have to set up a callback method (at library initialization). For instance:

@code
class MyApp
{
public:
    ...
    //callbacks
    static void lomse_request_handler_method(void* pThis, Request* pRequest);
}

void MyApp::initialize_lomse()
{
    ...
    //initialize the library with these values
    m_lomse.init_library(pixel_format, resolution, reverse_y_axis, m_lomseReporter);

    //set callback for requests
    m_lomse.set_request_callback(this, lomse_request_handler_method);
}

void MyApp::lomse_request_handler_method(void* pThis, Request* pRequest)
{
    static_cast<MyApp*>(pThis)->on_lomse_request(pRequest);
}

void MyApp::on_lomse_request(Request* pRequest)
{
    int type = pRequest->get_request_type();
    switch (type)
    {
        case k_dynamic_content_request:
            generate_dynamic_content( dynamic_cast<RequestDynamic*>(pRequest) );
            break;

        case k_get_font_filename:
            get_font_filename( dynamic_cast<RequestFont*>(pRequest) );
            break;

        default:
            LogError("Unknown request %d", type);
    }
}
@endcode

Lomse will make any necessary request by invoking this callback method. Therefore, requests are always handled in a single point in your application. 

When your callback method is invoked, it will receive as parameter an object derived from class Request, containing the information about the required information or platform dependent service. And Lomse process is paused until the user application provides the requested data.

The list of posible Requests is:
- RequestDynamic. While parsing an LDP document, a <tt>(dynamic)</tt> element has been found. Lomse is requesting user application for the dynamic content that must be inserted.
- RequestFont. The font used for an element is not available in Lomse package. Lomse requests the file path for the font.




*/

