/**

@page internal-model-overview Document internal representation

@tableofcontents

@section im-overview  The Internal Model overview

Nowadays, well-established web standards, such as XML, CSS and DOM, and the tendency to use the Internet browser as the runtime environment for applications, would suggest that any XML document should be internally stored as a DOM (Document Object Model) following the W3C specifications for valid HTML and well-formed XML documents.

But for Lomse the decision was not to represent internally the document as an XML DOM. Among other reasons, for music scores there are two important issues to consider:

-# Texts, HTML pages and XML documents work with a single hierarchy of elements and can be modelled by a tree structure. But music scores are not just a hierarchy of musical symbols, because some notations create relationships between other musical symbols. For instance, slurs, ties, dynamics wedges and many other notations create relationships between many notes a rests, sometimes in different staves and systems. As a consequece, a music score is better modelled by a lattice than by a tree.

-# Music has two dimensions, the horizontal one, the melody, and the vertical one, the harmony. When considering how to represent music, it is necessary to take into account that depending on the task to perform, music events (notes and rests) will have to be traversed following the music vertical dimension (time) or following the horizontal dimension (one voice after the other). Therefore the internal representation should be addecuate to facilitate both traversing needs.


The approach followed in Lomse has been to model the document by a tree structure of objects in memory, named the @IM, with additional structures that are synchronized when the @IM is modified. The root element of the @IM tree, stored in the Document object, represents the whole document. And the children of the root element represent the basic blocks for building a document: headers, paragraphs, music scores, lists, tables, images, etc. The @IM is, basically, a model similar to the XML DOM with two important differences for elements related to music scores:

- To facilitate traversing music scores by time and by voice, an additional model, the ColStaffObjs object, is maintained and is associated to the node representing the music score.

- Notations that create relationships between many musical symbols can not be nodes in the tree model as they would transform the tree into a lattice. Therefore, these notations are stored not as child nodes but as internal data. For instance, consider two tied notes. The @IM will include a <i>Tie</i> node as child of each tied note. But the real relationship is modelled by an external node pointed by the two Tie nodes:

@verbatim
                  Score
                    |
                Instrument
                    |
    +---------+-----+-------+---------+
    |         |             |         |
  Clef      Note          Note     Barline
              |             |
             Tie           Tie
               \            /         
  --- --- --- --- --- --- --- --- --- ----
                 \       /    This object is not part of the tree.
                  TieInfo     The two Tie elements store a pointer
                              to this shared object.

@endverbatim


As a summary, the document is modeled:

- By a tree of objects, the @IM, with an structure similar to an XML DOM.
- The root of the @IM is stored in the Document object, a facade object with some management methods.
- For nodes representing a music score, an additional structure is maintained: the ColStaffObjs object.
- For music notations representing relationships, additional external nodes create links between the tree nodes.

@attention When modifying nodes in the @IM related to a music score, additional steps must be taken for ensuring consistency and synchronising the external nodes representing relationships and the additional ColStaffObjs structure. External nodes representing music relationships between music elements are automatically maintained when using the appropriate API methods for modifying the @IM. And for maintaining the ColStaffObjs structure your application will have to invoke method ImoScore::close() after modifying the subtree representing the score.

It is important to note that the @IM and its associated structures is an abstract representation for a document, containing all necessary information to derive any other representation when needed. It is not oriented to any particular use (rendering, playback, printing, music analysis, document edition, ...) but try to serve all them equally. In this way the document can serve to the purpose of any view: a view can either be a print out of a conventional music score; or it can be a textual representation in LDP or any other language; or it can be a playback oriented representation, such a table of MIDI events; or any other representation for any purpose.

When a particular use is intended, the corresponding optimised representation is derived from the @IM. For instance, from the @IM the following purpose dependent representations are currently derived by Lomse:

* For interchange with other applications: LDP, LMD and MusicXML source code.
* For rendering: the @b GraphicModel class.
* For score playback: the @b SoundEventsTable class.




@section im-details The internal model in detail

The @IM is a tree of objects, derived from abstract class ImoObj. All these objects have @a Imo as class prefix and are sometimes named in Lomse documentation as @a IMOs: Internal Model Objects.

The root of the @IM tree is, normally, an object of class ImoDocument and represents the content of a whole document.
        
Class InternalModel represents the @IM and it is just a container for the root of the @IM.

Class Document represents the document. It contains the instance of the InternalModel class, which in turn stores the root node of the @IM. Your application can access this root node object by invoking Document::get_imodoc() method.

The @IM tree follows, basically, the same structure than that of a LenMus Document (LMD). For instance, the following LMD document:

@code{.xml}
<?xml version="1.0" encoding="UTF-8"?>
<lenmusdoc vers="0.0" language="en">
   <content> 
      <section level="1">1. A simple music score</section> 
      <para>
        The next example is just a simple music score.
        It only has one staff, a G clef, a key signature (A major)
        and two notes: a quarter note and an eighth note.
      </para> 
      <ldpmusic>
        (score (vers 2.0)
            (instrument
                (musicData
                    (clef G)
                    (key A)
                    (n a4 q)
                    (n c5 e)
                )
            )
        )
      </ldpmusic>
      <para>Do you like it?</para> 
   </content>
</lenmusdoc>@endcode

will render the following image:

@image html document-example.png "Image: Rendering of previous LMD document."


Internally, this document will be represented by the following tree:

@verbatim

                             ImoDocument
                                  |
                             ImoContent
                                  |
         +----------------+----------------+------------------+
         |                |                |                  |
     ImoHeading     ImoParagraph       ImoScore         ImoParagraph
         |                |                |                  |
      ImoText          ImoText       ImoInstrument         ImoText
                                           |
                                      ImoMusicData
                                           |
                      +-------------+-------------+---------+
                      |             |             |         |
                   ImoClef   ImoKeySignature   ImoNote   ImoNote
        
@endverbatim

The main hierarchy of the ImoObj objects is shown in the following diagram:

@verbatim
        
ImoObj                              Base class for all tree nodes
  |
  +-- ImoSimpleObj                  Non-renderizable. Just contains other objects or properties
  |                                 (e.g. option, style) 
  |           
  +---ImoContentObj                 Renderizable objects representing document content
        |
        +-- ImoBlockLevelObj        Block-level objects (e.g. document, table, list, score, ...):
        |     |
        |     +-- ImoBlocksContainer    * Block-level containers for block-level objects.
        |     |                           (e.g. document, table, list)
        |     |
        |     +-- ImoInlinesContainer   * Block-level containers for inline-level objs.
        |     |                           (e.g. paragraph, heading, anonymous-block)
        |     |
        |     +-- ImoScore              * A block-level object representing a music score
        |
        +-- ImoInlineLevelObj       Inline-level objects (e.g. wrapper[span], link, button, text, image)
        |
        +-- ImoScoreObj             Content specific for music scores:
              |
              +-- ImoStaffObj       * Main music content (e.g. note, clef, key signature, barline)
              |
              +-- ImoAuxObj         * Modifiers. Attached to other score objects (e.g. fermata, notation)
              |                     
              +-- ImoRelObj         * Relations. Relates two or more StaffObjs (e.g. slur, tie, beam)
                  

@endverbatim




@subsection scores-issues Music scores issues

For content other than music scores the @IM is similar to that of an HTML document. But for music scores there is some additional information added to the @IM tree:

-# The tree structure representing the music score content is complemented with an auxiliary representation, the ColStaffObjs object.

-# IMOs representing relationships between other IMOs (i.e. ImoTie) have to be linked to the objects that form part of the relationship. But these relation objects can not be modelled as tree nodes as that would transform the tree in a network. For instance, the following score with two tied notes:

@verbatim

    (score (vers 1.6)
        (instrument 
            (musicData
                (clef G)
                (key C)
                (n a4 q (tie 1 start))
                (n a4 q (tie 1 stop))
            )
        )
    )

   would create the following invalid tree:

                         ImoScore
                            |
                       ImoInstrument
                            |
                       ImoMusicData
                            |
           +-------------+--+----------+--------+
           |             |             |        |
        ImoClef   ImoKeySignature   ImoNote  ImoNote
                                       \        / 
                                        \      /
                                         ImoTie

@endverbatim

For this reason, the notation object itself, ImoTie in previous example, is not included as part of the tree, but stored in a special container class. This is described in detail in section :ref:`relation-auxobjs`.


Design rationale for the score model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the objects that define the score model::

    ImoObj
      |
      +-- ImoSimpleObj                  Just contains other objects or
      |     |                           properties
      |     |
      |     +-- ImoContainerObj         A container for ImoContentObj
      |           |
      |           +-- ImoInstrument     A container for ImoStaffObj
      |           
      +---ImoContentObj 
            |
            +-- ImoBoxLevelObj          A box-level object
            |     |
            |     +-- ImoScore          A container for instruments
            |
            +-- ImoScoreObj             Content for scores
                  |
                  +-- ImoStaffObj       Main music content objects
                  |
                  +-- ImoAuxObj         Modifiers. Can go attached to any score object
                  |                     
                  +-- ImoRelObj         Relations. Relates two or more StaffObjs.
                  
                  
                  
The approach followed has been to capture the score structure by splitting the representation in *containers* and *content* objects. For example, we could imagine the staff as a container for notes and rests. 

There are only two container classes: the score (``ImoScore`` object) and the instrument (``ImoInstrument`` class). The score is a container for instruments, and an instrument is a container for the objects representing the music for that instrument. But although bot, score and instrument, are container classes, there is an important difference between them: the score is a box level object, that is, it is a constituent block for document content. But not the instrument, which is just an auxiliary collection of objects. Because of this reason, score and instrument are in different places in the hierarchy. ``ImoScore`` derives from ``ImoBoxLevelObj`` and ``ImoInstrument`` from ``ImoContainerObj``.

All other score related objects are considered *content* objects, and are modeled by class ``ImoScoreObj``. All these objects that can be included in a score are classified in two main groups: staff objects (``ImoStaffObj`` class) and auxiliary objects (classes ``ImoAuxObj`` and ``ImoRelObj``).

An ``ImoInstrument`` is, basically, a collection of ``ImoStaffObj`` objects. You can think about staff objects as those symbols that are placed on the staff and are the basis for describing the music: I am are referring to symbols such as notes, rests, clefs, time and key signatures, barlines or other symbols with similar characteristics: objects that must me placed on the staff, are ordered by time and are essential to describe a melodic line (see: :ref:`staffobj-vs-auxobj`). But, in practice, instead of adding the ``ImoStaffObj`` nodes as direct children of ``ImoInstrument``, an auxiliary node ``ImoMusicData`` is created. This does not cause any performance or memory burden, facilitates the access to contained staff objects, and mimics the LDP structure, where all staff objects are defined inside a 'musicData' tag::

                 ImoScore
                     |
                ImoInstrument
                     |
                ImoMusicData
                     |
        +------------+------------+
        |            |            |
     ImoClef      ImoNote      ImoNote



.. _relation-auxobjs:

Auxiliary objects: classes ImoAuxObj and ImoRelObj 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All other objects in the score that are not ``ImoStaffObj`` objects are considered auxiliary objects, They are like *modifiers* describing additional properties or adding some editorial highlight on something. For instance, a fermata modifies the duration of a note. A tie modifies the two tied notes by joining their durations, And a title, adds editorial information to an score.

There are two types of auxiliary objects. The first group is formed by those auxiliary objects representing additional properties or modifiers for the owner object (one-to-one relations). For instance, a fermata modifies the duration of the note owning the fermata. These auxiliary objects will be named *simple auxiliary objects* and will be modeled by objects derived from class ``ImoAuxObj``. They are included in the internal model just as children nodes in the objects they modify. For instance, a fermata in a note is modeled by a ``ImoFermata`` child node, whose parent is the ``ImoNote`` object. Or the title for an score is an ``ImoAuxObj`` attached to the ``ImoScore``. The following example illustrates this:

.. figure:: fermata-simple-auxobj.png
    :scale: 75 %
    :class: center
    :alt: Modeling a fermata (simple auxiliary object)

    **Figure:** Modeling a fermata (simple auxiliary object).
    

In LDP this score is written as::

    (score (vers 1.6)
        (instrument 
            (musicData
                (clef G)
                (n g4 q)
                (n c5 q (fermata above))
                (barline)
            )
        )
    )

And it will create the following internal tree::

                        ImoScore
                            |
                       ImoInstrument
                            |
                       ImoMusicData
                            |
        +------------+------+-----+------------+
        |            |            |            |
     ImoClef      ImoNote      ImoNote    ImoBarline
                                  |
                            ImoAttachments
                                  |
                              ImoFermata


Notice that, in practice, ``ImoFermata`` is not a direct child of ``ImoNote``. Instead, an intermediate container node ``ImoAttachments`` is created. This is just to keep together all ``ImoAuxObj`` objects attached to a parent node.

``ImoAuxObjs`` can be attached to *any* score object. For instance, a title to an score, And also to other ``ImoAuxObj`` objects. For instance a text notice attached to a fermata that, in turn , is attached to a note.



The other group of auxiliary objects is formed by those objects modeling a relationship **between two or more staff objects**. For instance, a tie, and slur, or a dynamics wedge. These auxiliary objects are modeled by abstract class ``ImoRelObj``.

``ImoRelObj`` objects can not be included in the internal tree as children of the staff objects that are part of the relationship, as this would transform the tree into a network. For instance, consider the following score with two tied notes:

.. figure:: tie-rel-auxobj.png
    :scale: 75 %
    :class: center
    :alt: A tie (relationship auxiliary object) can not be modeled as a child node.

    **Figure:** A tie (relationship auxiliary object) can not be modeled as a child node.
    

In LDP this score is written as::

    (score (vers 1.6)
        (instrument 
            (musicData
                (clef G)
                (n a4 q (tie 1 start))
                (n a4 q (tie 1 stop))
                (barline)
            )
        )
    )

If the tie is modeled as a child node common to the related notes, it would create the following invalid tree::

                 ImoScore
                     |
                ImoInstrument
                     |
                ImoMusicData
                     |
       +--------+----+---+---------+
       |        |        |         |
    ImoClef  ImoNote  ImoNote  ImoBarline
                \        / 
                 \      /
                  ImoTie



For this reason, ``ImoRelObj`` objects can not be nodes in the tree model. To solve this problem, they are stored not as child nodes but as internal data in a list of attached ``ImoRelObj`` objects. This list is contained in node ``ImoRelations``::


                       ImoScore
                           |
                      ImoInstrument
                           |
                      ImoMusicData
                           |
       +-------------+-----+-------+---------+
       |             |             |         |
    ImoClef       ImoNote       ImoNote  ImoBarline
                     |             |
                ImoRelations  ImoRelations 
                     \            /         
  --- --- --- --- --- --- --- --- --- ---- ---
                       \       /    Not part of the tree. Stored
                         ImoTie     as object data




So, simple auxiliary objects (``ImoAuxObj``) are inserted as children in a ``ImoAttachments`` child node, and relation auxiliary objects (``ImoRelObj``) objects are stored as internal data in a ``ImoRelations`` child node::


                                 |
                     +-----------+-----------+
                     |                       |
                  ImoNote                 ImoNote
                     |                       |
           +---------+---------+       ImoRelations
           |                   |             |
    ImoAttachments       ImoRelations        |
           |                   \            /         
      ImoFermata          - --- --- --- --- --- ---- ---
                                 \       /    Not part of the tree 
                                   ImoTie         




..
    Implications for tree traversing
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    As all ``ImoObj`` are organized in a tree they can be accessed by tree traversing methods or by using visitors. For instance, ``Tree`` class provides methods such as::

        get_parent()
        append_child()
        remove_child()


    But nodes of class ``ImoAttachments`` are an exception. These nodes can have children (simple ``ImoAuxObjs``), and these children will be traversed by normal tree traversing methods. But ``ImoAuxObjs`` has also an internal list containing all attached ``ImoRelObj`` objects. As these objects are not part of the tree, special traversing methods are needed.

    To simplify precesses, the existence of this exception and its treatment I've tried to isolate and enclosed the treatment of this exception. For this, * **use of ``Tree`` traversing methods is forbidden** * and, to replace them, new methods are created. These new method takes care of proper treatment for ``ImoAttachment`` nodes. To hide the original ``Tree`` methods and replace them by new ones, that could deal properly with ``ImoAttachment`` nodes, I derived from ``Tree`` a new ``ImoTree`` class. And overrided some methods::

        get_parent_imo()
        append_child_imo()
        remove_child_imo()

    But for ``Visitors`` I didn't find a clean solution, so when programming a new ``Visitor`` class you have to take care of dealing with ``ImoAttachments`` nodes peculiarities.



Relation data objects: class ImoRelDataObj
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In any relationship you will find two types of data:

#. Data about the relationship itself: its existence, its properties and information that is common to all participants. For instance, class ``ImoBeam`` represents the grouping of several notes/rests by using a beam, and it contains the information that is common to all notes included in the beam, such as the beam color.

#. Specific data for each participant in the relationship, such as its role. For instance, for a beam, it is necessary to specify, for each note in the beam, the details about how to draw the beam for that note: as continuous line, as a forward hook, as a backward hook, etc.


Objects derived from class ``ImoRelObj`` represents a relationship, but they only contains the first type of data: the relationship properties and information that is common to all participants.

For modeling the specific data about each participant, another base class is used: class ``ImoRelDataObj``. For instance, to model a group of tree beamed notes, the following objects are created:

* One ``ImoBeam`` object, derived from ``ImoRelObj``. It represents the beam.
* Three ``ImoBeamData'' objects, derived from ``ImoRelDataObj``. They represent the specific beaming information for each note: i.e. the beam type.

Each data object is associated to each participant object (i.e. the notes in the beam) by creating a ``std::pair`` object. And all these pairs are stored in the ``ImoRelObj`` in a list of participants. Thus, the internal structure for any ``ImoRelObj`` is the following::


    ptrs. to participants:  ImoStaffObj          ImoStaffObj
                               ^                    ^
    ptrs. to participants'     |                    |
    data (i.e. its role):      | ImoRelDataObj      | ImoRelDataObj
                               |     ^              |     ^
                               |     |              |     | 
                       +- -- --|-- --|-- -- -- -- --|-- --|-- -- -- ...
    List of            |  first|     |second   first|     |second
    participants -----------> std::pair ---------> std::pair -------> ...
                       |       
                       |       
                       +- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ...   
                       ImoRelObj



In some relations, there is no specific data to store in the ``ImoRelDataObj`` objects. In these cases no `ImoRelDataObj`` is created, and the internal pointers in ``ImoRelObj`` contains NULL.

Here are the objects involved in modeling currently implemented relationships::

    ImoRelObj                  ImoRelDataObj
      |                           |
      +-- ImoBeam                 +-- ImoBeamData
      +-- ImoChord                |      no chord data needed
      +-- ImoTie                  +-- ImoTieData
      +-- ImoTuplet               +-- ImoTupletData
      +-- ImoSlur                 +-- ImoSlurData




Notes about some objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ImoSpacer and anchor objects
---------------------------------

``ImoSpacer`` is an ``ImoStaffObj`` whose purpose is to add more space between the staff objects than precede and follow the ``ImoSpacer``. That is, it is like the `space` character in text processing.

But ``ImoSpacer`` plays also an important role: it is the *anchor* object for attaching auxiliary objects to an staff. As ``ImoAuxObj`` objects are not ``ImoStaffObj`` they can not be included directly as content for an staff. Remember that ``ImoAuxObj`` objects can only be attached to staff objects. To avoid creating artificial dependencies (attaching auxiliary objects to notes or rest that have nothing to do with the attached object) it is better to attach the auxiliary object to a 'neutral' staff object with no meaning, an *anchor* object: an ``ImoSpacer`` of zero width.


..
    Owning ImoAuxObj objects
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    simple ImoAuxObj --> any ImoContentObj
    ImoRelObj --> only to ImoStaffObj

    It should be possible to have AuxObjs not attached only to StaffObjs but to many places. For example: assume a text box (AuxObj) owned by a fermata (AuxObj), owned by a note (StaffObj).

    Another example: Score titles, Instrument names, etc are examples of AuxObjs not owned by StaffObjs.

    This implies that AuxObjs can own other AuxObjs. But AuxObjs layout requires that:
      a) the owner must provide positioning information. AuxObjs are relative positioned
      b) the owner must be able to do TenthsToLogical conversions.

    Therefore, the only restriction would be that the root of owners chain must not be an AuxObj. In summary:

     * In order to own AuxObjs it is necessary to be able to do TenthsToLogical conversions.
     * An AuxObj can own other AuxObjs but the root of owners chain must not be an AuxObj (otherwise it will never be rendered!).
     * At creation, an AuxObj has no owner. The owner must be set at attachment time, and must be updated at each attachment/detachment
     * If its owner is a StaffObj, measurements can be in tenths, as can be converted to LUnits. Otherwise, if owner chain reaches a VStaff/Staff, measurements can also be in tenths and this grand-father VStaff will be used for units conversion. Otherwise, units must be absolute.



..
    LDP Language: history and evolution
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    From time to time I receive an email asking why I developed LDP instead of using any existing language. This is the story.

    When I stated the LenMus Phonascus program, in 2002, I didn't have any previous experience about modeling music. And it was just a hobby program with no particular aims apart of helping me to practice music reading and aural training. 

    I googled for information about existing languages and for academic papers on music representation. I found no academic papers for learning. Contrary to general believe, all academic documentation is not free knowledge but very expensive paywalled information, normally not affordable by general public. At minimum you need access to a public library with a deep budget. 

    As to existing languages, I found references to languages such as abc [1]_, LillyPond [2]_ SCORE [3]_ and MusicXML [4]_. Except MusicXML, all others didn't have (IMHO) a clean syntax: they were too oriented to manually edited music scores so, their syntaxes were full of implicit assumed information, abbreviated constructs and `tricks', making it more complex to process the files and to understand. On the contrary, MusicXML had a clear, modern syntax based on XML. As my needs were simple, basically representing notes and rests, I immediately choose MusicXML: as it was XML it would be easy to parse, and to ignore all information that I was not going to process. Unfortunately, in those days (2002), MusicXML was a starting project (version 0.7) and it was inadequate to my purposes as I needed positioning information and MusicXML 0.7 didn't have plans to include this information. Michael Good, responsible for MusicXML, had written several times about this and always had a clear position on this. For instance:



    So I needed some simple to process, with positioning information, and I didn't intended to display full scores, not even chords, but simple melodic lines, I decided to design my own language. As it was not possible for me to learn about problems, approaches and solutions from academic publications, this was also a good opportunity to gain first hand experience, about music representation problems. So I started designing my own representation language. I named it "LDP" (Lenguaje De Partituras, meaning 'language for music scores').

    But I also though that, as I had not experience in music, it would be wise to have some grounding references and so I decided to follow the MusicXML model. A second reason to follow it was that I liked to implement export/import MusicXML and so, to simplify this objective, my internal representation should not deviate too much from MusicXML. This was the main reason for the ``goFwd`` and ``goBack`` elements. I didn't like these procedural tags inside a declarative language. For me, a better solution would have been something similar to the overlay constructor in the GUIDO language [3]_ but:

    #. I gave priority to not deviating too much from MusicXML.
    #. I didn't knew about GUIDO much more later, when some LDP decisions had been taken.


    Although recognizing the advantages of XML syntax, I decided to use a LISP like syntax instead of XML. This was due to the work involved in typing XML files. I had no XML editor and typing paired opening/closing XML tags was much more typing than the real content itself! And, in future, if necessary or convenient, it would be trivial to switch to XML and convert existing LDP files (by the way, time for this switching has already arrived).

    Later, in version 2.0, MusicXML changed its mind and allowed including positioning information. But it was too late for me. I had already created LDP, a lot of code was in place, and Phonascus was running.

    Nowadays, I've learned a lot about music representation and, for scores, I feel no need to continue using and developing LDP, so a switch to MusicXML would be perfectly possible. The only deterrent is that MusicXML is limited to describing scores, but I need to describe full books, with texts, images, exercises, scores and any other content common in books. But again, MusicXML seems to be anchored in do not allowing additional content: only musical content. MusicXML answer for this need is to use HTML + CSS and embed scores on it::

    Although this can be a perfect solution in future, if MusicXML continues growing, it requires that MusicXML be supported by browsers as standard web content, and that is not current situation. So, to have a solution today and to not depend on how MusicXML evolves, I'm somehow forced to continue developing and extending LDP.



    _[2] The MusicXML language. http://www.recordare.com/xml.html
    _[3] GUIDO
    _[4] 


.. _staffobj-vs-auxobj:

ImoStaffObj vs. ImoAuxObj: implementation criteria
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When having to implement a new notation object, sometimes it is difficult to decide if it should be an ``ImoStaffObj`` or an ``ImoAuxObj``. The best approach is to consider how the music line (melody) is affected by the presence of the new notational object: 

#. Notations that are better associated to the staff than to a particular staff object. The notation affects to all the music defined after it. In this cases, normally the best option is to model that notational object as an ``ImoStaffObj``. For instance, at first sight a metronome mark looks like a text at beginning of the score. So you could thing of it as an attached text and, therefore, think about modeling metronome marks as an ``ImoAuxObj``. But, a metronome mark has musical meaning, and affects the tempo of all notes/rest coming after the metronome mark. So, it is a kind of musical event that affects all coming musical events. Because of this, it is a kind of staff object not a property of a particular staff object.

#. Notations with no meaning when associated to an staff. They only have musical meaning when associated to an staff object and affects only to that staff object. In these cases, normally the best option is to model that notational object as an ``ImoAuxObj`` (or ``ImoRelObj`` is several objects are involved). For instance, lyrics, or all articulations and technical markup associated to notes/rests.

#. Elements with no musical meaning but affecting all staff objects. For example, objects for layout control, such as page breaks or system breaks. They are better modeled as ``ImoStaffObj`` objects.


In summary, the key rule is use ``ImoStaffObj`` for measure-attached objects that should affect all objects coming after it. On the contrary, use ``ImoAuxObj``/``ImoRelObj`` for note-attached objects that should affect only to the parent objects. +


@subsection im-hierarchy Internal model objects hierarchy

The base class for @IM objects is ImoObj. From it, a hierachy of derived classes is created. 

At the root of this hierarchy, ImoObj specializes in three main types: 

-# Temporay Data Transfer Objects used during model building (ImoDto), but never part of the final tree. They have 'Dto' suffix.
-# No renderizable objects containing just properties or relationships (ImoSimpleObj).
-# Objects describing the content of the document (ImoContentObj). They are renderizable and have properties.

Content objects (ImoContentObj) can be subdivided into two main groups (although no base class for them has been created): components, representing atomic objects and containers, that is objects that have components.

Specific objects for music score are divided into two main categories: staff objects and auxiliary objects. Staff objects represent the 'main' content of the music (basically notes, rests, clefs, key signatures and time signatures), that is, those objects that must me rendered on a staff and that are are positiones by time (music 'events).

All other notations are considered auxiliary objects. In turn, there are two main types of auxiliary objects: those modelling a simple musical notation (i.e. a fermata, an accent, an attacehd text) and those modelling a relationship between objects (i.e. a tie, and slur, a dynamics wedge).

* Simple auxiliary objects require only a parent; for instance, in a fermata, the owner is a note, a rest or a barline. Therefore, simple auxiliary objects are modelled by a single ImoAuxObj object and can be stored as tree nodes.

* On the contrary, relationship objects need to be linked to all the objects that are part of the relationship. For instance in a tie, the two tied notes. Relations can not be modelled explicitly as a node linked by two or more nodes, as this would transform the tree in a network. For this reason, RelObjs are objects that never will be tree nodes; instead, these objects will be stored in a special container node (ImoAttachments) and treated as data inside this node, not as child nodes of it.

The following picture shows current hierarchy of objects. Those marked with '(A)' are abstract classes. In some cases the equivalence to HTML tags is marked:

@verbatim

    ImoObj (A) (type, id)
      |
      +-- ImoDto (A) () Data Transfer Objects (Dto suffix).  Temporay use 
      |     |           during model building, but never part of the final
      |     |           tree (the internal model)
      |     |
      |     +-- ImoBeamDto 
      |     +-- ImoColorDto
      |     +-- ImoFontStyleDto  
      |     +-- ImoSlurDto
      |     +-- ImoTieDto
      |     +-- ImoTimeModificationDto
      |     +-- ImoTupletDto
      |     +-- ImoBorderDto - not used!!!!
      |     +-- ImoPointDto - not used!!!!
      |     +-- ImoSizeDto - not used!!!!
      |
      |
      +-- ImoSimpleObj (A) () No renderizable
      |     |                 They just contains other objects or properties
      |     |
      |     |  ___________________________________________________________
      |     |  === Value Objects to encapsulate data ==
      |     |     Some of them are stored as nodes in the tree; others,
      |     |     as member variables in other objects. Nevertheless,.
      |     |     all defined as tree nodes for uniform treatment.
      |     |
      |     +-- ImoBezierInfo -- data (*) in SlurData, TieData, TieDto, SlurDto
      |     +-- (ImoFiguredBassInfo)
      |     +-- (ImoFigBassIntervalInfo)
      |     +-- ImoInstrGroup -- data in ImoInstrument(*)
      |     +-- ImoLineStyle -- data in ImoTextBox, ImoLine(*)
      |     +-- ImoLyricsText_info,
      |     +-- ImoLyricsExtend_info,
      |     +-- ImoMidiInfo -- data in ImoInstrument
      |     +-- ImoPageInfo -- data in ImoDocument, ImoScore
      |     +-- ImoStaffInfo -- data in ImoInstrument(list)
      |     +-- ImoSystemInfo -- data in ImoScore
      |     +-- ImoTextInfo (string, style) -- data in ImoScoreText
      |     +-- ImoTextBlockInfo,
      |     +-- ImoTextStyle,
      |     |
      |     |       // Nodes in tree
      |     |
      |     +-- ImoOptionInfo - node in ImoOptions
      |     +-- ImoParamInfo - node in ImoDynamics
      |     +-- ImoStyle - not node, but element in ImoStyles (std::map)
      |     |
      |     |  ___________________________________________________________
      |     |  === Value objects to contain relation data for a node =====
      |     |
      |     +-- ImoRelDataObj (A)
      |     |     +-- ImoBeamData
      |     |     +-- ImoSlurData
      |     |     +-- ImoTieData
      |     |     +-- ImoTupletData
      |     |     +-- ImoGlissandoData
      |     |  
      |     |  ___________________________________________________________
      |     |  === Container objects; no additional properties ===========
      |     |
      |     +-- ImoCollection (A) () A node. Branches are the stored objs
      |     |     |
      |     |     +-- ImoAttachments  <auxobj>
      |     |     +-- ImoInstruments  <instrument>
      |     |     +-- ImoInstrGroups  <group>
      |     |     +-- ImoMusicData    <staffobj>
      |     |     +-- ImoOptions      <option>
      |     |     +-- ImoTableSection(A)
      |     |           +-- ImoTableHead [thead]    <tableRow>
      |     |           +-- ImoTableBody [tbody]    <tableRow>
      |     |  
      |     +-- ImoStyles     <style>  [a map to store style objects]
      |     +-- ImoRelations  <relobj> [a list to store relobjs]
      |     |
      |     +-- ImoContainerObj (A) ()
      |           |
      |           +-- ImoInstrument (... , [musicData])
      |     
      |
      +---ImoContentObj (A) (style, location, visible, [attachments])
            |
            +-- ImoBlockLevelObj (A)
            |     |       Abstract class for all block-level objects
            |     |
            |     +-- ImoScore
            |     |
            |     +-- ImoBlocksContainer (A)
            |     |     |       A block-level container for block-level objects. All 

            |     |     |       ImoBlocksContainer objects (except ImoContent and
            |     |     |       ImoDynamic) have a ImoContent object as container.
            |     |     |
            |     |     +-- ImoDocument [html/body]
            |     |     +-- ImoContent [div] - a generic block-level container
            |     |     |     +-- ImoDynamic [object] 
            |     |     |
            |     |     +-- ImoMultiColumn - a container subdivided in columns
            |     |     +-- ImoTable [table] - a container for table related objects
            |     |     +-- ImoList [ol, ul]
            |     |     +-- ImoTableRow [tr] - a container for a row of cells
            |     |     +-- ImoListItem [li]
            |     |     +-- ImoTableCell [td, th]
            |     |
            |     +-- ImoInlinesContainer (A)
            |           |        A block-level container for inline-level objs.
            |           |
            |           +-- ImoAnonymousBlock []
            |           +-- ImoParagraph [p]
            |           +-- ImoHeading [h1, h2, h3, h4, h5]
            |
            |
            +-- ImoInlineLevelObj (A)
            |     |       Inline-level objects
            |     |
            |     |
            |     +-- ImoBoxInline (A) (size, content) - an abstract 
            |     |     |        inline-level box container.
            |     |     |
            |     |     +-- ImoInlineWrapper [span] - A generic inline-box container
            |     |     +-- ImoLink [a] - Anchor 
            |     |
            |     +-- ImoButton [button] - a button
            |     +-- ImoControl (control) - A user defined GUI obj.
            |     |     +-- ImoScorePlayer - A control for managing score playback
            |     |
            |     +-- ImoTextItem [] - a piece of text with the same style
            |     +-- ImoImage [img] - Inline image                        
            |               
            |
            +-- ImoScoreObj (A) (color) content for scores
                  |
                  +-- ImoStaffObj (A) (timePos, numStaff)
                  |     |
                  |     +-- ImoBarline
                  |     +-- ImoClef
                  |     +-- ImoKeySignature
                  |     +-- ImoMetronomeMark
                  |     +-- ImoTimeSignature
                  |     +-- ImoGoBackFwd
                  |     +-- ImoSystemBreak
                  |     +-- ImoSpacer
                  |     +-- ImoNoteRest (A) (noteType, dots, voice)
                  |           +-- ImoNote
                  |           +-- ImoRest
                  |
                  +-- ImoAuxObj (A) () Can go attached to any score object
                  |     |
                  |     +-- ImoArticulation (A)
                  |     |     +-- ImoArticulationSymbol
                  |     |     +-- ImoArticulationLine
                  |     |
                  |     +-- ImoFermata
                  |     +-- ImoDynamicsMark
                  |     +-- ImoOrnament
                  |     +-- ImoTechnical
                  |     |
                  |     +-- ImoBlock (A)
                  |     |     +-- ImoTextBox (anchor line, paragraphs)
                  |     |
                  |     +-- ImoScoreLine
                  |     +-- ImoScoreText (text-info)
                  |           +-- ImoScoreTitle (h-align) 
                  |         ( +-- ImoInstrNameAbbrev )
                  | 
                  +-- ImoRelObj (A)  Relates two or more StaffObjs
                        +-- ImoTie
                        +-- ImoBeam
                        +-- ImoChord
                        +-- ImoSlur
                        +-- ImoTuplet
                        +-- ImoGlissando

@endverbatim

Marked with '*': Double inheritance: also from ImoAuxObj class.



@subsection imoobj-issues Notes about some ImoObj objects

<h3>ImoContentObj and ImoTable</h3>

Both contain ImoStyle objects. But they can not be stored as child nodes (either directly or by using an ImoCollection object) because all ImoStyle objects are also stored at ImoDocumnet level. Storeing them also in other ImoObj object would produce crashes when deleting the ImoObj tree, because these duplicated ImoStyle objects will be deleted twice.


*/

